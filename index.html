<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Word Wheel Crossword Game</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            padding: 0;
            background-color: #f7f9fc;
            color: #333;
            overflow-x: hidden; /* Prevent horizontal scrolling */
        }
        
        /* Removed h1 and subtitle styles to save space */
        
        .game-container {
            display: flex;
            flex-direction: column;
            max-width: 1200px;
            margin: 0 auto;
            gap: 2px; /* Reduced gap */
            min-height: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        .game-content {
            display: grid;
            width: 100%;
            gap: 5px;
            min-height: 0;
            box-sizing: border-box;
        }
        
        .wheel-section {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            overflow: visible;
            min-height: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        .wheel-container {
            position: relative;
            margin: 0 auto;
            width: min(280px, 60vw);  
            height: min(280px, 60vw);
            touch-action: none;
            box-sizing: border-box;
        }
        
        .letter {
            position: absolute;
            width: 56px;
            height: 56px;
            border-radius: 50%;
            background-color: #3498db;
            color: white;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 26px;
            font-weight: bold;
            user-select: none;
            cursor: pointer;
            transition: transform 0.2s, background-color 0.2s;
            transform-origin: center;
            z-index: 1;
        }
        
        .letter.selected {
            background-color: #2ecc71;
            transform: scale(1.1);
        }
        
        .current-word {
            font-size: 28px;
            margin: 2px 0;
            height: 30px;
            width: 100%;
            text-align: center;
            font-weight: bold;
            color: #2c3e50;
            box-sizing: border-box;
        }
        
        .controls {
            display: flex;
            gap: 5px; /* Reduced from 10px */
            margin: 8px 0;
            flex-wrap: nowrap; /* Prevent wrapping by default */
            justify-content: center;
            width: 100%;
        }
        
        button {
            padding: 10px 18px;
            font-size: 16px;
            background-color: #3498db;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            transition: background-color 0.2s;
            font-weight: bold;
            overflow: hidden; /* Prevent text overflow */
            text-overflow: ellipsis; /* Add ellipsis for overflow */
            white-space: nowrap; /* Keep text on one line */
        }
        
        button:hover {
            background-color: #2980b9;
        }
        
        button:disabled {
            background-color: #bdc3c7;
            cursor: not-allowed;
        }
        
        button#new-game-btn {
            background-color: #27ae60;
        }
        
        button#new-game-btn:hover {
            background-color: #219653;
        }
        
        button#clear-btn {
            background-color: #e74c3c;
        }
        
        button#clear-btn:hover {
            background-color: #c0392b;
        }
        
        button#debug-btn {
            background-color: #9b59b6;
        }
        
        button#debug-btn:hover {
            background-color: #8e44ad;
        }
        
        .crossword-container {
            margin: 0;
            position: relative;
            overflow: visible;
            width: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
            flex: 1;
        }
        
        .crossword-grid {
            display: grid;
            gap: 1px;
            margin: 0 auto;
            border: 2px solid #2c3e50;
            background-color: #2c3e50;
            max-width: 100%;
            max-height: 100%;
            transform-origin: center;
            /* Add transform-box to ensure transforms are relative to content box */
            transform-box: content-box;
            /* Ensure there's no unexpected overflow */
            box-sizing: border-box;
        }
        
        .crossword-cell {
            width: 40px;
            height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 22px;
            font-weight: bold;
            position: relative;
            border: 1px solid #bdc3c7;
            text-transform: uppercase;
        }
        
        .crossword-cell.filled {
            background-color: #e6e6e6; /* Light gray for unfilled word cells */
        }
        
        .crossword-cell.correct {
            background-color: white; /* White for correctly filled cells */
        }
        
        .crossword-cell.empty {
            background-color: #2c3e50; /* Dark blue/gray for non-word cells */
            border: none;
        }
        
        .dictionary-upload {
            text-align: center;
            padding: 30px;
            background-color: #f8f9fa;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            margin: 50px auto;
            max-width: 500px;
        }
        
        .dictionary-upload h3 {
            margin-top: 0;
            color: #2c3e50;
        }
        
        .dictionary-upload p {
            margin-bottom: 20px;
            color: #7f8c8d;
        }
        
        .dictionary-upload input[type="file"] {
            display: block;
            width: 100%;
            margin-bottom: 15px;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 4px;
        }
        
        #use-default-dict {
            background-color: #95a5a6;
            margin-top: 10px;
        }
        
        #use-default-dict:hover {
            background-color: #7f8c8d;
        }
        
        .cell-number {
            position: absolute;
            top: 2px;
            left: 2px;
            font-size: 10px;
            font-weight: normal;
            color: #7f8c8d;
        }
        
        .words-found-container {
            width: 100%;
            order: 3;
            margin-top: 20px;
            max-width: 1200px;
            margin-left: auto;
            margin-right: auto;
            /* Remove overflow and max-height to allow natural page scrolling */
            overflow: visible;
        }
        
        .words-found {
            width: 100%;
            overflow: visible;
            padding: 0 10px;
        }
        
        .words-found h3 {
            margin-top: 0;
            color: #2c3e50;
        }
        
        .words-found-list {
            list-style-type: none;
            padding: 0;
            margin: 0;
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
        }
        
        .words-found-list li {
            background-color: #e8f4fc;
            padding: 5px 10px;
            border-radius: 15px;
            font-weight: bold;
            color: #3498db;
        }
        
        .message {
            position: fixed;
            top: 10px;
            right: 10px;
            font-weight: bold;
            min-height: 20px;
            font-size: 18px;
            background-color: rgba(255, 255, 255, 0.9);
            padding: 8px 12px;
            border-radius: 5px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            z-index: 1000;
            max-width: 200px;
            text-align: center;
        }
        
        .success {
            color: #27ae60;
            border-left: 4px solid #27ae60;
        }
        
        .error {
            color: #e74c3c;
            border-left: 4px solid #e74c3c;
        }
        
        /* Path for word selection */
        .selection-path {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 10;
        }
        
        /* Portrait-specific layout */
        @media (orientation: portrait) {
            .game-content {
                grid-template-columns: 1fr;
                grid-template-rows: auto auto;
                grid-template-areas: 
                    "wheel"
                    "grid";
                width: 100%;
                height: auto;
                margin-bottom: 5px;
                padding-top: 3px;
                overflow: visible;
                gap: 10px;
            }
            
            .wheel-section {
                grid-area: wheel;
                padding: 0;
                display: flex;
                flex-direction: column;
                justify-content: center;
                align-items: center;
                width: 100%;
                margin: 0;
                /* Keep a compact height in portrait mode */
                height: auto;
                min-height: min-content;
                max-height: 30vh; /* Reduced from 33vh */
                box-sizing: border-box;
            }
            
            .grid-section {
                grid-area: grid;
                width: 100%;
                display: flex;
                flex-direction: column;
                align-items: center;
                justify-content: center;
                overflow: visible;
                box-sizing: border-box;
                padding: 0;
                height: auto;
                min-height: auto;
                /* Limit max height to ensure enough space for words-found */
                max-height: 60vh;
            }
            
            .word-wheel {
                display: flex;
                flex-direction: column;
                justify-content: center;
                align-items: center;
                gap: 10px;
                width: 100%;
                max-width: 100%;
                padding: 0;
                position: relative;
                margin: 0 auto;
            }
            
            .wheel-container {
                margin: 0 auto;
                width: min(240px, 60vw);
                height: min(240px, 60vw);
                position: relative;
            }
            
            .controls {
                display: flex;
                flex-direction: row;
                flex-wrap: wrap;
                margin: 10px 0;
                height: auto;
                gap: 10px;
                justify-content: center;
                width: 100%;
            }
            
            .current-word {
                width: 100%;
                text-align: center;
                margin: 5px 0;
                min-height: 30px;
            }
            
            .crossword-container {
                width: 100%;
                display: flex;
                justify-content: center;
                align-items: center;
                margin: 0 auto;
                box-sizing: border-box;
            }
            
            .crossword-grid {
                transform-origin: center;
                margin: 0 auto;
                max-width: 100%;
                max-height: 60vh;
                display: inline-grid;
            }
            
            .words-found-container {
                margin-top: 10px;
                position: relative;
                width: 100%;
            }
            
            .words-found {
                overflow-y: visible;
                max-height: none;
            }
        }
        
        /* Landscape-specific layout */
        @media (orientation: landscape) {
            .game-content {
                grid-template-columns: auto 1fr;
                grid-template-rows: auto;
                grid-template-areas: "wheel grid";
                width: 100%;
                height: auto;
                min-height: 0;
                max-height: 95vh;
                padding: 0;
                margin: 0;
                overflow: visible;
                gap: 20px;
                align-items: center;
            }
            
            .wheel-section {
                grid-area: wheel;
                width: auto;
                padding: 0;
                display: flex;
                flex-direction: column;
                justify-content: center;
                align-items: center;
                height: auto;
                min-height: min-content;
                max-height: 90vh;
                box-sizing: border-box;
            }
            
            .grid-section {
                grid-area: grid;
                display: flex;
                flex-direction: column;
                justify-content: center;
                align-items: center;
                overflow: visible;
                height: auto;
                padding: 0;
                margin: 0;
                box-sizing: border-box;
                /* Allow grid to take remaining width */
                width: 100%;
                max-height: 90vh;
            }
            
            .wheel-container {
                width: min(220px, 20vw);
                height: min(220px, 20vw);
                margin: 0 auto;
                max-height: 60vh;
                aspect-ratio: 1/1;
            }
            
            .word-wheel {
                flex-direction: column;
                justify-content: center;
                align-items: center;
                width: 100%;
                height: auto;
                display: flex;
                gap: 10px;
            }
            
            .controls {
                display: flex;
                flex-direction: row;
                flex-wrap: nowrap;
                justify-content: center;
                margin: 5px 0;
                width: 100%;
                gap: 5px;
                padding: 0;
            }
            
            .controls button {
                padding: 5px;
                min-width: 40px;
                max-width: 70px;
                font-size: 12px;
                flex: 1;
                white-space: nowrap;
                overflow: hidden;
                text-overflow: ellipsis;
            }
            
            .crossword-container {
                width: 100%;
                height: auto;
                display: flex;
                justify-content: center;
                align-items: center;
                max-height: 85vh;
            }
            
            .crossword-grid {
                transform-origin: center;
                margin: 0 auto;
                max-width: 100%;
                max-height: 80vh;
                display: inline-grid;
            }
            
            .words-found-container {
                width: 100%;
                margin-top: 10px;
            }
        }
        
        .words-found-list li.invalid {
            background-color: #fce8e8;
            color: #e74c3c;
            text-decoration: line-through;
        }
        
        /* Animation for found words */
        @keyframes celebrate {
            0% { transform: scale(1); }
            50% { transform: scale(1.2); }
            100% { transform: scale(1); }
        }
        
        .celebrating {
            animation: celebrate 0.5s ease;
        }
        
        /* Longest word celebration */
        .longest-word-banner {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%) scale(0);
            background: linear-gradient(135deg, #f39c12, #e74c3c);
            color: white;
            padding: 20px 40px;
            border-radius: 10px;
            font-size: 24px;
            font-weight: bold;
            box-shadow: 0 4px 20px rgba(0,0,0,0.3);
            z-index: 1000;
            text-align: center;
            transition: transform 0.5s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }
        
        .longest-word-banner.show {
            transform: translate(-50%, -50%) scale(1);
        }
        
        .longest-word-info {
            margin-top: 10px;
            padding: 15px;
            background-color: #f5f6fa;
            border-radius: 8px;
            border-left: 4px solid #3498db;
            font-weight: bold;
            color: #2c3e50;
        }
        
        /* Ensure the game section fits properly in viewport */
        #game-section {
            margin: 0;
            padding: 2px 0 0 0; /* Reduced padding */
            display: flex;
            flex-direction: column;
            min-height: 0;
            height: auto;
            box-sizing: border-box;
            /* Add border to create visual containment */
            border-radius: 8px;
            background-color: #ffffff;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.05);
        }
        
        .grid-section {
            display: flex;
            flex-direction: column;
            height: auto;
            min-height: 0;
            position: relative;
            overflow: visible;
            justify-content: center;
            align-items: center;
            width: 100%;
            margin-bottom: 10px;
            box-sizing: border-box;
        }
        
        .grid-buttons {
            display: flex;
            gap: 10px;
            margin: 5px auto 10px auto;
            justify-content: center;
            padding: 0;
            width: 100%;
            max-width: 1200px;
            position: relative;
            z-index: 2;
            box-sizing: border-box;
            /* Create a consistent container */
            background-color: #f7f9fc;
            border-top: 1px solid #e1e8ed;
        }
        
        /* Ensure consistent button sizes in grid buttons */
        .grid-buttons button {
            min-width: 140px;
            height: 44px;
            padding: 10px 18px;
            font-size: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
            margin: 8px 0;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
            border-radius: 6px;
            transition: transform 0.1s ease, box-shadow 0.1s ease;
        }
        
        .grid-buttons button:hover {
            transform: translateY(-1px);
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.15);
        }
        
        .grid-buttons button:active {
            transform: translateY(0);
            box-shadow: 0 1px 2px rgba(0, 0, 0, 0.1);
        }
    </style>
</head>
<body>
    <div class="game-container">
        <div class="loading" id="loading" style="display: none;">
            <div class="loading-spinner"></div>
            <p>Generating puzzle...</p>
        </div>
        
        <div class="longest-word-banner" id="longest-word-banner">
            <div>Congratulations!</div>
            <div>You found the longest word!</div>
            <div id="longest-word-text"></div>
        </div>
        
        <div class="message" id="message"></div>
        
        <div id="game-section">
            <div class="game-content">
                <div class="wheel-section">
                    <div class="word-wheel">
                        <div class="wheel-container" id="wheel-container">
                            <svg class="selection-path" id="selection-path">
                                <path id="path" stroke="#2ecc71" stroke-width="5" fill="none" stroke-linecap="round" stroke-linejoin="round"></path>
                            </svg>
                        </div>
                        <div class="current-word" id="current-word"></div>
                        <div class="controls">
                            <button id="clear-btn">Clear</button>
                            <button id="shuffle-btn">Shuffle</button>
                            <button id="submit-btn">Submit</button>
                        </div>
                    </div>
                </div>
                
                <div class="grid-section">
                    <div class="crossword-container">
                        <div class="crossword-grid" id="crossword-grid"></div>
                    </div>
                </div>
            </div>
            
            <!-- Game controls moved inside the game section for better alignment -->
            <div class="grid-buttons">
                <button id="debug-btn">Show Answers</button>
                <button id="new-game-btn">New Game</button>
            </div>
        </div>
    </div>

    <div class="words-found-container">
        <div class="words-found">
            <h3>Words Found: <span id="words-found-count">0</span>/<span id="total-words-count">0</span></h3>
            <h4>Valid Words</h4>
            <ul class="words-found-list" id="words-found-list"></ul>
            <h4>Invalid Attempts</h4>
            <ul class="words-found-list" id="invalid-words-list"></ul>
        </div>
    </div>

    <script>
        // Wait for DOM to be fully loaded
        document.addEventListener('DOMContentLoaded', function() {
            // Trie data structure for efficient word lookup
            class TrieNode {
                constructor() {
                    this.children = {};
                    this.isEndOfWord = false;
                }
            }
            
            class Trie {
                constructor() {
                    this.root = new TrieNode();
                }
                
                insert(word) {
                    let node = this.root;
                    for (const char of word) {
                        if (!node.children[char]) {
                            node.children[char] = new TrieNode();
                        }
                        node = node.children[char];
                    }
                    node.isEndOfWord = true;
                }
                
                search(word) {
                    let node = this.root;
                    for (const char of word) {
                        if (!node.children[char]) {
                            return false;
                        }
                        node = node.children[char];
                    }
                    return node.isEndOfWord;
                }
                
                getAllWords() {
                    const result = [];
                    
                    function dfs(node, prefix) {
                        if (node.isEndOfWord) {
                            result.push(prefix);
                        }
                        
                        for (const char in node.children) {
                            dfs(node.children[char], prefix + char);
                        }
                    }
                    
                    dfs(this.root, '');
                    return result;
                }
            }
            
            // Main game class
            class WordWheelCrossword {
                constructor() {
                    this.initializeProperties();
                    this.bindMethods();
                    this.setupDOMElements();
                    this.setupEventListeners();
                    this.loadDictionary();
                    this.initGame();
                }
                
                initializeProperties() {
                    // Game properties
                    this.letters = [];
                    this.currentWord = '';
                    this.selectedIndices = [];
                    this.validWords = [];
                    this.crosswordGrid = [];
                    this.gridSize = 0;
                    this.placedWords = [];
                    this.clues = [];
                    this.foundWords = [];
                    this.letterElements = [];
                    this.isDragging = false;
                    this.pathPoints = [];
                    this.dictionary = new Trie();
                    this.debugMode = false;
                    this.invalidAttempts = new Set();
                    this.longestWord = ''; // Track the longest word
                    this.longestWordFound = false; // Track if longest word has been found
                    
                    // Touch/mouse tracking for tap vs drag detection
                    this.touchStartX = 0;
                    this.touchStartY = 0;
                    this.touchStartTime = 0;
                    this.mouseStartX = 0;
                    this.mouseStartY = 0;
                    this.mouseStartTime = 0;
                    this.hasMoved = false;
                }
                
                bindMethods() {
                    // Bind class methods to this instance
                    this.initGame = this.initGame.bind(this);
                    this.selectLetters = this.selectLetters.bind(this);
                    this.findValidWords = this.findValidWords.bind(this);
                    this.generateCrossword = this.generateCrossword.bind(this);
                    this.renderLetterWheel = this.renderLetterWheel.bind(this);
                    this.renderCrosswordGrid = this.renderCrosswordGrid.bind(this);
                    this.handleTouchStart = this.handleTouchStart.bind(this);
                    this.handleMouseDown = this.handleMouseDown.bind(this);
                    this.handleTouchMove = this.handleTouchMove.bind(this);
                    this.handleMouseMove = this.handleMouseMove.bind(this);
                    this.handleTouchEnd = this.handleTouchEnd.bind(this);
                    this.handleMouseUp = this.handleMouseUp.bind(this);
                    this.handleLetterClick = this.handleLetterClick.bind(this);
                    this.clearSelection = this.clearSelection.bind(this);
                    this.shuffleLetters = this.shuffleLetters.bind(this);
                    this.submitWord = this.submitWord.bind(this);
                    this.updateCurrentWord = this.updateCurrentWord.bind(this);
                    this.updateWordsList = this.updateWordsList.bind(this);
                    this.displayMessage = this.displayMessage.bind(this);
                    this.updateSelectionPath = this.updateSelectionPath.bind(this);
                    this.toggleDebugView = this.toggleDebugView.bind(this);
                    this.findLongestWord = this.findLongestWord.bind(this);
                    this.celebrateLongestWord = this.celebrateLongestWord.bind(this);
                    this.animateFoundWord = this.animateFoundWord.bind(this);
                    this.adjustLayout = this.adjustLayout.bind(this);
                    this.updateCrosswordForWord = this.updateCrosswordForWord.bind(this);
                }
                
                setupDOMElements() {
                    // Get DOM elements
                    this.wheelContainer = document.getElementById('wheel-container');
                    this.currentWordElement = document.getElementById('current-word');
                    this.submitBtn = document.getElementById('submit-btn');
                    this.clearBtn = document.getElementById('clear-btn');
                    this.shuffleBtn = document.getElementById('shuffle-btn');
                    this.crosswordGridElement = document.getElementById('crossword-grid');
                    this.messageElement = document.getElementById('message');
                    this.wordsFoundList = document.getElementById('words-found-list');
                    this.wordsFoundCount = document.getElementById('words-found-count');
                    this.totalWordsCount = document.getElementById('total-words-count');
                    this.newGameBtn = document.getElementById('new-game-btn');
                    this.loadingElement = document.getElementById('loading');
                    this.selectionPath = document.getElementById('path');
                    this.invalidWordsList = document.getElementById('invalid-words-list');
                    this.longestWordBanner = document.getElementById('longest-word-banner');
                    this.longestWordText = document.getElementById('longest-word-text');
                    this.debugBtn = document.getElementById('debug-btn');
                }
                
                setupEventListeners() {
                    // Game control buttons
                    if (this.clearBtn) this.clearBtn.addEventListener('click', this.clearSelection);
                    if (this.shuffleBtn) this.shuffleBtn.addEventListener('click', this.shuffleLetters);
                    if (this.submitBtn) this.submitBtn.addEventListener('click', this.submitWord);
                    if (this.newGameBtn) this.newGameBtn.addEventListener('click', this.initGame);
                    if (this.debugBtn) this.debugBtn.addEventListener('click', this.toggleDebugView);
                    
                    // Wheel interaction
                    if (this.wheelContainer) {
                        this.wheelContainer.addEventListener('touchstart', this.handleTouchStart, { passive: false });
                        this.wheelContainer.addEventListener('mousedown', this.handleMouseDown);
                    }
                    
                    // Add resize and orientation change listeners to adjust layout
                    window.addEventListener('resize', this.adjustLayout.bind(this));
                    window.addEventListener('orientationchange', () => {
                        // Multiple adjustments after orientation change to ensure proper rendering
                        setTimeout(this.adjustLayout.bind(this), 50);
                        setTimeout(this.adjustLayout.bind(this), 300);
                        setTimeout(this.adjustLayout.bind(this), 600);
                    });
                    
                    // Initial layout adjustment
                    this.adjustLayout();
                    
                    // Use requestAnimationFrame for a more reliable layout adjustment
                    this.adjustLayout();
                    
                    // For layout issues that might occur due to dynamic content loading
                    window.addEventListener('load', this.adjustLayout.bind(this));
                }
                
                adjustLayout() {
                    // Create a reusable function that we can call via requestAnimationFrame
                    const performLayout = () => this._doAdjustLayout();
                    
                    // Schedule the layout adjustment for the next animation frame
                    requestAnimationFrame(performLayout);
                }
                
                _doAdjustLayout() {
                    const isPortrait = window.matchMedia('(orientation: portrait)').matches;
                    const isMobile = window.innerWidth <= 800;
                    const viewportWidth = window.innerWidth;
                    const viewportHeight = window.innerHeight;
                    
                    // Get the elements
                    const gameContent = document.querySelector('.game-content');
                    const wheelSection = document.querySelector('.wheel-section');
                    const gridSection = document.querySelector('.grid-section');
                    const crosswordGrid = document.getElementById('crossword-grid');
                    const wordWheel = document.querySelector('.word-wheel');
                    const wordsFoundContainer = document.querySelector('.words-found-container');
                    
                    if (!gameContent || !wheelSection || !gridSection) return;
                    
                    // Set height to auto to allow natural page scrolling
                    document.querySelector('.game-container').style.height = 'auto';
                    
                    // Zero padding at the top to save space
                    document.querySelector('#game-section').style.paddingTop = '0px';
                    
                    // Set layout based on orientation
                    if (isPortrait) {
                        // Portrait layout - let CSS grid handle the layout
                        gameContent.style.gridTemplateAreas = '"wheel" "grid"';
                        gameContent.style.gridTemplateColumns = '1fr';
                        gameContent.style.gridTemplateRows = 'auto auto';
                        
                        // Wheel sizing - in portrait, use a smaller percentage of viewport height
                        const maxWheelSize = Math.min(viewportWidth * 0.65, 260);
                        const wheelSize = Math.min(maxWheelSize, viewportHeight * 0.22);
                        
                        if (this.wheelContainer) {
                            this.wheelContainer.style.width = `${wheelSize}px`;
                            this.wheelContainer.style.height = `${wheelSize}px`;
                            this.wheelContainer.style.margin = '0 auto';
                        }
                        
                        // Let CSS handle the grid section
                        if (wordsFoundContainer) {
                            wordsFoundContainer.style.maxHeight = '';
                            wordsFoundContainer.style.overflowY = 'visible';
                        }
                        
                    } else {
                        // Landscape layout - let CSS grid handle the layout
                        gameContent.style.gridTemplateAreas = '"wheel grid"';
                        gameContent.style.gridTemplateColumns = 'auto 1fr';
                        gameContent.style.gridTemplateRows = 'auto';
                        
                        // Calculate available height
                        const availableHeight = Math.min(viewportHeight * 0.8, 500);
                        
                        // In landscape, optimize wheel size for available height
                        const maxWheelSize = Math.min(viewportHeight * 0.45, 220);
                        // Calculate wheel size for landscape
                        const wheelSize = Math.min(maxWheelSize, availableHeight * 0.8);
                        
                        if (this.wheelContainer) {
                            this.wheelContainer.style.width = `${wheelSize}px`;
                            this.wheelContainer.style.height = `${wheelSize}px`;
                            this.wheelContainer.style.margin = '0 auto';
                        }
                        
                        // Let grid section adjust based on CSS grid layout
                        if (wordsFoundContainer) {
                            wordsFoundContainer.style.maxHeight = '20vh';
                            wordsFoundContainer.style.overflowY = 'auto';
                        }
                    }
                    
                    // Adjust letter wheel when size changes
                    this.renderLetterWheel();
                    
                    // Adjust grid cell size based on available space
                    if (crosswordGrid && this.crosswordGrid && this.crosswordGrid.length > 0) {
                        const gridWidth = this.crosswordGrid[0].length;
                        const gridHeight = this.crosswordGrid.length;
                        
                        const gridSectionWidth = gridSection.clientWidth;
                        // Use the full grid section height now that buttons are outside
                        const gridSectionHeight = gridSection.clientHeight;
                        
                        // Add extra safety margins for calculation
                        const safetyMarginWidth = isPortrait ? 30 : 20;
                        const safetyMarginHeight = isPortrait ? 30 : 20;
                        
                        // Calculate max cell size that will fit with extra margins
                        const maxCellWidth = Math.floor((gridSectionWidth - safetyMarginWidth) / gridWidth);
                        const maxCellHeight = Math.floor((gridSectionHeight - safetyMarginHeight) / gridHeight);
                        
                        // Calculate initial cell size based on available space
                        let cellSize = Math.min(maxCellWidth, maxCellHeight, 40); // Max of 40px
                        
                        // Ensure minimum cell size for usability
                        cellSize = Math.max(cellSize, 20);
                        
                        // For very large grids, adjust cell size directly to maintain proportions
                        if (gridWidth > 15 || gridHeight > 15) {
                            // Larger reduction for very large grids
                            cellSize = Math.max(Math.floor(cellSize * 0.85), 20);
                        }
                        
                        // Apply cell size to all cells
                        const cells = crosswordGrid.querySelectorAll('.crossword-cell');
                        cells.forEach(cell => {
                            cell.style.width = `${cellSize}px`;
                            cell.style.height = `${cellSize}px`;
                            cell.style.fontSize = `${Math.max(cellSize * 0.55, 14)}px`;
                        });
                        
                        // Update grid template
                        crosswordGrid.style.gridTemplateColumns = `repeat(${gridWidth}, ${cellSize}px)`;
                        crosswordGrid.style.gridTemplateRows = `repeat(${gridHeight}, ${cellSize}px)`;
                        
                        // Calculate aspect ratio of the grid
                        const gridAspectRatio = gridWidth / gridHeight;
                        
                        // Calculate natural grid size based on cell size
                        const naturalGridWidth = cellSize * gridWidth;
                        const naturalGridHeight = cellSize * gridHeight;
                        
                        // Determine available space
                        // In portrait mode, ensure we leave room for the wheel
                        const maxAvailableWidth = gridSectionWidth * 0.95; // 5% margin
                        const maxAvailableHeight = isPortrait ? 
                            Math.min(viewportHeight * 0.65, gridSectionHeight) * 0.95 : // In portrait
                            gridSectionHeight * 0.95; // In landscape
                        
                        // Calculate potential scales based on width and height constraints
                        const scaleX = maxAvailableWidth / naturalGridWidth;
                        const scaleY = maxAvailableHeight / naturalGridHeight;
                        
                        // Pick the limiting dimension (the smaller scale)
                        // Never scale up (limit to 1.0)
                        let scale = Math.min(scaleX, scaleY, 1.0);
                        
                        // Apply a reasonable minimum size (never go below 35% of original)
                        const minScale = 0.35;
                        scale = Math.max(scale, minScale);
                        
                        // For very wide or tall grids, apply a reasonable adjustment factor
                        // but don't iteratively reduce multiple times
                        if (gridWidth > 12 || gridHeight > 12) {
                            scale *= 0.9; // Single 10% reduction for large grids
                        }
                        
                        // Always apply scaling, regardless of whether we think it fits
                        crosswordGrid.style.transform = `scale(${scale})`;
                        
                        // Log grid dimensions for debugging
                        console.log(`Grid dimensions: ${naturalGridWidth}x${naturalGridHeight}, Available: ${maxAvailableWidth}x${maxAvailableHeight}, Scale: ${scale}`);
                    }
                }
                
                loadDictionary() {
                    fetch('wordlist.txt')
                        .then(response => response.text())
                        .then(text => {
                            // Split into words and filter empty lines
                            const words = text.split(/\r?\n/).filter(word => word.trim().length > 0);
                            
                            // Clear any existing dictionary
                            this.dictionary = new Trie();
                            
                            // Add words to dictionary
                            for (const word of words) {
                                this.dictionary.insert(word.toLowerCase().trim());
                            }
                            
                            console.log(`Loaded ${words.length} words from wordlist.txt`);
                            
                            // Start the game
                            this.initGame();
                        })
                        .catch(error => {
                            console.error('Error loading wordlist:', error);
                            alert('Error loading word list. Please try again.');
                        });
                }
                
                initGame() {
                    // Store current scroll position
                    const scrollY = window.scrollY;
                    
                    // Only generate a puzzle if we have a dictionary loaded
                    if (this.dictionary.getAllWords().length === 0) {
                        console.error("No dictionary loaded. Cannot generate puzzle.");
                        return;
                    }
                    
                    // Reset scroll position to top for new game
                    window.scrollTo(0, 0);
                    
                    // Show loading spinner
                    if (this.loadingElement) {
                        this.loadingElement.style.display = 'flex';
                    }
                    
                    // Reset game state
                    this.currentWord = '';
                    this.selectedIndices = [];
                    this.foundWords = [];
                    this.invalidAttempts = new Set();
                    
                    if (this.currentWordElement) this.currentWordElement.textContent = '';
                    if (this.messageElement) this.messageElement.textContent = '';
                    if (this.messageElement) this.messageElement.className = 'message';
                    
                    // Generate puzzle asynchronously with maximum attempts
                    setTimeout(() => {
                        try {
                            // Try to generate a valid grid (max 5 attempts)
                            this.generateValidGrid(5);
                            
                            // Render the game elements
                            this.renderLetterWheel();
                            this.renderCrosswordGrid();
                            this.updateWordsList();
                            this.adjustLayout(); // Adjust layout after rendering
                            
                            // Hide loading spinner
                            if (this.loadingElement) {
                                this.loadingElement.style.display = 'none';
                            }
                            
                            // Use requestAnimationFrame for reliable layout adjustment
                            this.adjustLayout();
                        } catch (error) {
                            console.error("Error generating puzzle:", error);
                            if (this.loadingElement) {
                                this.loadingElement.style.display = 'none';
                            }
                            alert("An error occurred while generating the puzzle. Please try again.");
                        }
                    }, 100);
                }
                
                // New method to generate a valid grid that includes all possible words
                generateValidGrid(maxAttempts) {
                    console.log(`Attempting to generate a valid grid (max ${maxAttempts} attempts)...`);
                    
                    for (let attempt = 1; attempt <= maxAttempts; attempt++) {
                        console.log(`Grid generation attempt ${attempt}/${maxAttempts}`);
                        
                        // Select letters and find possible words
                        this.selectLetters();
                        this.findValidWords();
                        
                        // Keep track of the number of possible words
                        const initialWordCount = this.allPossibleWords.length;
                        console.log(`Found ${initialWordCount} possible words`);
                        
                        // Generate crossword grid
                        this.generateCrossword();
                        
                        // Check if all words were placed in the grid
                        const unplacedWords = this.allPossibleWords.filter(w => !this.placedWords.includes(w));
                        const placementRatio = this.placedWords.length / initialWordCount;
                        
                        // Consider the grid valid if:
                        // 1. All words were placed, or
                        // 2. We placed at least 80% of the words and have at least 10 words in the grid
                        if (unplacedWords.length === 0 || 
                            (placementRatio >= 0.8 && this.placedWords.length >= 10)) {
                            console.log(`✅ Generated a valid grid on attempt ${attempt}`);
                            console.log(`  - Placed ${this.placedWords.length} out of ${initialWordCount} words (${Math.round(placementRatio*100)}%)`);
                            return true; // Successfully generated a valid grid
                        }
                        
                        console.log(`❌ Grid attempt ${attempt} rejected: placed only ${this.placedWords.length} out of ${initialWordCount} words (${Math.round(placementRatio*100)}%)`);
                    }
                    
                    // If we've reached here, we've used all our attempts and still don't have a good grid
                    // Just use the last generated grid as a fallback
                    console.warn("Could not generate an optimal grid after maximum attempts. Using the last generated grid.");
                    return false;
                }
                
                selectLetters() {
                    // Get all 7-letter words from dictionary
                    const allWords = this.dictionary.getAllWords();
                    const sevenLetterWords = allWords.filter(word => word.length === 7);
                    
                    if (sevenLetterWords.length === 0) {
                        console.error("No 7-letter words found in dictionary!");
                        return;
                    }
                    
                    // Select a random 7-letter word
                    const anchorWord = sevenLetterWords[Math.floor(Math.random() * sevenLetterWords.length)];
                    console.log("Anchor word:", anchorWord); // For debugging
                    
                    // Use the letters from the word
                    this.letters = anchorWord.split('');
                    
                    // Shuffle the letters
                    for (let i = this.letters.length - 1; i > 0; i--) {
                        const j = Math.floor(Math.random() * (i + 1));
                        [this.letters[i], this.letters[j]] = [this.letters[j], this.letters[i]];
                    }
                }
                
                findValidWords() {
                    // Create a frequency map of our letters
                    const letterFreq = {};
                    for (const letter of this.letters) {
                        letterFreq[letter] = (letterFreq[letter] || 0) + 1;
                    }
                    
                    // Add debug logging
                    console.log("Starting valid word search...");
                    
                    // Check each dictionary word to see if it can be formed with our letters
                    this.allPossibleWords = []; // Store all possible words from our letters
                    const allDictionaryWords = this.dictionary.getAllWords();
                    
                    // Debug: Count words by length
                    const wordsByLength = {};
                    
                    for (const word of allDictionaryWords) {
                        // Skip words that are too short
                        if (word.length < 3) {
                            continue;
                        }
                        
                        // Count words by length for debugging
                        wordsByLength[word.length] = (wordsByLength[word.length] || 0) + 1;
                        
                        // Check if all letters in the word are available in our pool
                        const wordLetterFreq = {};
                        let valid = true;
                        
                        for (const letter of word) {
                            wordLetterFreq[letter] = (wordLetterFreq[letter] || 0) + 1;
                            if (!letterFreq[letter] || wordLetterFreq[letter] > letterFreq[letter]) {
                                valid = false;
                                break;
                            }
                        }
                        
                        if (valid) {
                            this.allPossibleWords.push(word);
                        }
                    }
                    
                    // Debug logging
                    console.log("Words found by length:", wordsByLength);
                    console.log("Possible words found:", this.allPossibleWords.length);
                    console.log("Possible words by length:", this.allPossibleWords.reduce((acc, word) => {
                        acc[word.length] = (acc[word.length] || 0) + 1;
                        return acc;
                    }, {}));
                    
                    // Make sure we have some words for the crossword
                    if (this.allPossibleWords.length < 5) {
                        console.warn("Not enough valid words found! Reselecting letters.");
                        this.selectLetters();
                        this.findValidWords();
                        return;
                    }
                    
                    // Limit to 30 words maximum, prioritizing longer words
                    if (this.allPossibleWords.length > 30) {
                        // Sort by length (descending) to prioritize longer words
                        this.allPossibleWords.sort((a, b) => b.length - a.length);
                        
                        // Make sure we keep at least one 7-letter word if available
                        const sevenLetterWord = this.allPossibleWords.find(w => w.length === 7);
                        const otherWords = this.allPossibleWords.filter(w => w.length < 7);
                        
                        // Take up to 29 other words (leaving room for the 7-letter word)
                        const selectedWords = otherWords.slice(0, 29);
                        
                        // Add the 7-letter word back if we found one
                        this.allPossibleWords = sevenLetterWord ? [sevenLetterWord, ...selectedWords] : selectedWords;
                    }
                    
                    // Note: we'll set validWords after generating the crossword
                    // to ensure it only contains words that actually appear in the grid
                }
                
                generateCrossword() {
                    // Start with a large empty grid (coordinates will be relative)
                    this.gridSize = 50; // Large enough for any reasonable puzzle
                    const center = Math.floor(this.gridSize / 2);
                    
                    // Initialize empty grid
                    this.crosswordGrid = Array(this.gridSize).fill().map(() => 
                        Array(this.gridSize).fill().map(() => ({ letter: '', wordIndices: [] }))
                    );
                    
                    // Reset tracking variables
                    this.placedWords = [];
                    this.clues = [];
                    
                    // Sort words by length (descending)
                    const sortedWords = [...this.allPossibleWords].sort((a, b) => b.length - a.length);
                    if (sortedWords.length === 0) return;
                    
                    // Track grid bounds
                    let minRow = center;
                    let maxRow = center;
                    let minCol = center;
                    let maxCol = center;
                    
                    // Place first (longest) word horizontally in the center
                    const firstWord = sortedWords[0];
                    this.placeWord(firstWord, center, center, true);
                    this.placedWords.push(firstWord);
                    this.clues.push({ word: firstWord, row: center, col: center, horizontal: true });
                    
                    // Update bounds for first word
                    maxCol = center + firstWord.length - 1;
                    
                    // Consider each remaining word in descending length order
                    for (let i = 1; i < sortedWords.length; i++) {
                        const word = sortedWords[i];
                        
                        // Find all valid placements for this word
                        const placements = [];
                        
                        // Scan the current grid for possible intersection points
                        for (let r = Math.max(0, minRow - word.length); r <= Math.min(this.gridSize - 1, maxRow + word.length); r++) {
                            for (let c = Math.max(0, minCol - word.length); c <= Math.min(this.gridSize - 1, maxCol + word.length); c++) {
                                // Skip empty cells - we need intersections
                                if (!this.crosswordGrid[r][c] || this.crosswordGrid[r][c].letter === '') continue;
                                
                                const gridLetter = this.crosswordGrid[r][c].letter;
                                
                                // Try to match each letter in the word
                                for (let w = 0; w < word.length; w++) {
                                    if (word[w] === gridLetter) {
                                        // Try horizontal placement
                                        const hRow = r;
                                        const hCol = c - w;
                                        if (this.isValidPlacement(word, hRow, hCol, true)) {
                                            // Calculate new bounds if we place here
                                            const newMinRow = Math.min(minRow, hRow);
                                            const newMaxRow = Math.max(maxRow, hRow);
                                            const newMinCol = Math.min(minCol, hCol);
                                            const newMaxCol = Math.max(maxCol, hCol + word.length - 1);
                                            
                                            // Calculate area expansion
                                            const currentArea = (maxRow - minRow + 1) * (maxCol - minCol + 1);
                                            const newArea = (newMaxRow - newMinRow + 1) * (newMaxCol - newMinCol + 1);
                                            const expansion = newArea - currentArea;
                                            
                                            placements.push({
                                                row: hRow,
                                                col: hCol,
                                                horizontal: true,
                                                expansion: expansion,
                                                newBounds: {minRow: newMinRow, maxRow: newMaxRow, minCol: newMinCol, maxCol: newMaxCol}
                                            });
                                        }
                                        
                                        // Try vertical placement
                                        const vRow = r - w;
                                        const vCol = c;
                                        if (this.isValidPlacement(word, vRow, vCol, false)) {
                                            // Calculate new bounds if we place here
                                            const newMinRow = Math.min(minRow, vRow);
                                            const newMaxRow = Math.max(maxRow, vRow + word.length - 1);
                                            const newMinCol = Math.min(minCol, vCol);
                                            const newMaxCol = Math.max(maxCol, vCol);
                                            
                                            // Calculate area expansion
                                            const currentArea = (maxRow - minRow + 1) * (maxCol - minCol + 1);
                                            const newArea = (newMaxRow - newMinRow + 1) * (newMaxCol - newMinCol + 1);
                                            const expansion = newArea - currentArea;
                                            
                                            placements.push({
                                                row: vRow,
                                                col: vCol,
                                                horizontal: false,
                                                expansion: expansion,
                                                newBounds: {minRow: newMinRow, maxRow: newMaxRow, minCol: newMinCol, maxCol: newMaxCol}
                                            });
                                        }
                                    }
                                }
                            }
                        }
                        
                        // If we found valid placements, choose the one with minimum expansion
                        if (placements.length > 0) {
                            // Sort by expansion (ascending)
                            placements.sort((a, b) => a.expansion - b.expansion);
                            
                            // Select the placement with minimum bounding box expansion
                            const bestPlacement = placements[0];
                            
                            // Place the word and update grid
                            this.placeWord(word, bestPlacement.row, bestPlacement.col, bestPlacement.horizontal);
                            this.placedWords.push(word);
                            this.clues.push({
                                word,
                                row: bestPlacement.row,
                                col: bestPlacement.col,
                                horizontal: bestPlacement.horizontal
                            });
                            
                            // Update bounds
                            minRow = bestPlacement.newBounds.minRow;
                            maxRow = bestPlacement.newBounds.maxRow;
                            minCol = bestPlacement.newBounds.minCol;
                            maxCol = bestPlacement.newBounds.maxCol;
                        }
                        
                        // Limit to 12 words for playability
                        if (this.placedWords.length >= 12) break;
                    }
                    
                    // Number the grid cells for clues
                    this.numberGrid();
                    
                    // Trim grid to actual content plus 1 cell margin
                    const padding = 1;
                    const trimMinRow = Math.max(0, minRow - padding);
                    const trimMaxRow = Math.min(this.gridSize - 1, maxRow + padding);
                    const trimMinCol = Math.max(0, minCol - padding);
                    const trimMaxCol = Math.min(this.gridSize - 1, maxCol + padding);
                    
                    this.trimToGrid(trimMinRow, trimMaxRow, trimMinCol, trimMaxCol);
                    
                    // After placing words, find the longest word
                    this.findLongestWord();
                    
                    // IMPORTANT: Set validWords to ONLY include words that were successfully 
                    // placed in the grid
                    this.validWords = [...this.placedWords];
                    console.log("Valid words that appear in the grid:", this.validWords.length);
                    
                    // Log words that were originally valid but couldn't be placed
                    const unplacedWords = this.allPossibleWords.filter(w => !this.placedWords.includes(w));
                    console.log("Words that could be formed but not placed in grid:", unplacedWords);
                }
                
                isValidPlacement(word, startRow, startCol, horizontal) {
                    // Check if word is in bounds
                    if (horizontal) {
                        if (startRow < 0 || startRow >= this.gridSize) return false;
                        if (startCol < 0 || startCol + word.length > this.gridSize) return false;
                    } else {
                        if (startCol < 0 || startCol >= this.gridSize) return false;
                        if (startRow < 0 || startRow + word.length > this.gridSize) return false;
                    }
                    
                    // Check for conflicts and ensure proper intersections
                    let intersectionCount = 0;
                    
                    // Check for characters immediately before and after the word
                    if (horizontal) {
                        if (startCol > 0 && this.crosswordGrid[startRow] && 
                            this.crosswordGrid[startRow][startCol - 1] && 
                            this.crosswordGrid[startRow][startCol - 1].letter !== '') {
                            return false; // Letter before word
                        }
                        if (startCol + word.length < this.gridSize && 
                            this.crosswordGrid[startRow] && 
                            this.crosswordGrid[startRow][startCol + word.length] && 
                            this.crosswordGrid[startRow][startCol + word.length].letter !== '') {
                            return false; // Letter after word
                        }
                    } else {
                        if (startRow > 0 && this.crosswordGrid[startRow - 1] && 
                            this.crosswordGrid[startRow - 1][startCol] && 
                            this.crosswordGrid[startRow - 1][startCol].letter !== '') {
                            return false; // Letter above word
                        }
                        if (startRow + word.length < this.gridSize && 
                            this.crosswordGrid[startRow + word.length] && 
                            this.crosswordGrid[startRow + word.length][startCol] && 
                            this.crosswordGrid[startRow + word.length][startCol].letter !== '') {
                            return false; // Letter below word
                        }
                    }
                    
                    // Check each position of the word
                    for (let i = 0; i < word.length; i++) {
                        const row = horizontal ? startRow : startRow + i;
                        const col = horizontal ? startCol + i : startCol;
                        
                        // Ensure grid cell exists
                        if (!this.crosswordGrid[row] || !this.crosswordGrid[row][col]) {
                            return false;
                        }
                        
                        const currentCell = this.crosswordGrid[row][col];
                        
                        if (currentCell.letter !== '') {
                            // If cell has a letter, it must match our word
                            if (currentCell.letter !== word[i]) {
                                return false; // Conflict with existing letter
                            }
                            
                            // Valid intersection
                            intersectionCount++;
                        } else {
                            // For empty cells, check ALL adjacent cells that aren't part of this word
                            
                            // Check above
                            if (row > 0 && this.crosswordGrid[row - 1] && 
                                this.crosswordGrid[row - 1][col] && 
                                this.crosswordGrid[row - 1][col].letter !== '' && 
                                !(horizontal === false && i > 0)) {
                                return false; // Unwanted adjacency above
                            }
                            
                            // Check below
                            if (row < this.gridSize - 1 && this.crosswordGrid[row + 1] && 
                                this.crosswordGrid[row + 1][col] && 
                                this.crosswordGrid[row + 1][col].letter !== '' && 
                                !(horizontal === false && i < word.length - 1)) {
                                return false; // Unwanted adjacency below
                            }
                            
                            // Check left
                            if (col > 0 && this.crosswordGrid[row] && 
                                this.crosswordGrid[row][col - 1] && 
                                this.crosswordGrid[row][col - 1].letter !== '' && 
                                !(horizontal === true && i > 0)) {
                                return false; // Unwanted adjacency to the left
                            }
                            
                            // Check right
                            if (col < this.gridSize - 1 && this.crosswordGrid[row] && 
                                this.crosswordGrid[row][col + 1] && 
                                this.crosswordGrid[row][col + 1].letter !== '' && 
                                !(horizontal === true && i < word.length - 1)) {
                                return false; // Unwanted adjacency to the right
                            }
                        }
                    }
                    
                    // Valid placement must have at least one intersection
                    return intersectionCount > 0;
                }
                
                placeWord(word, startRow, startCol, horizontal) {
                    const wordIndex = this.placedWords.length;
                    
                    for (let i = 0; i < word.length; i++) {
                        const row = horizontal ? startRow : startRow + i;
                        const col = horizontal ? startCol + i : startCol;
                        
                        // Check bounds
                        if (row < 0 || row >= this.gridSize || col < 0 || col >= this.gridSize) {
                            console.error(`Attempted to place letter out of bounds: (${row},${col})`);
                            continue;
                        }
                        
                        // Ensure grid cell exists
                        if (!this.crosswordGrid[row]) {
                            this.crosswordGrid[row] = [];
                        }
                        
                        if (!this.crosswordGrid[row][col]) {
                            this.crosswordGrid[row][col] = { letter: '', wordIndices: [] };
                        }
                        
                        // Place the letter
                        this.crosswordGrid[row][col].letter = word[i];
                        
                        // Initialize wordIndices if it doesn't exist
                        if (!this.crosswordGrid[row][col].wordIndices) {
                            this.crosswordGrid[row][col].wordIndices = [];
                        }
                        
                        // Add the word index to this cell
                        if (!this.crosswordGrid[row][col].wordIndices.includes(wordIndex)) {
                            this.crosswordGrid[row][col].wordIndices.push(wordIndex);
                        }
                    }
                }
                
                trimToGrid(minRow, maxRow, minCol, maxCol) {
                    // Create a new grid with just the bounds we need
                    const newHeight = maxRow - minRow + 1;
                    const newWidth = maxCol - minCol + 1;
                    
                    // Initialize new grid
                    const newGrid = [];
                    for (let r = 0; r < newHeight; r++) {
                        newGrid[r] = [];
                        for (let c = 0; c < newWidth; c++) {
                            newGrid[r][c] = { letter: '', wordIndices: [] };
                        }
                    }
                    
                    // Copy content to the new grid
                    for (let r = 0; r < newHeight; r++) {
                        for (let c = 0; c < newWidth; c++) {
                            const sourceRow = r + minRow;
                            const sourceCol = c + minCol;
                            
                            if (sourceRow < this.gridSize && sourceCol < this.gridSize && 
                                this.crosswordGrid[sourceRow] && this.crosswordGrid[sourceRow][sourceCol]) {
                                newGrid[r][c] = this.crosswordGrid[sourceRow][sourceCol];
                            }
                        }
                    }
                    
                    // Update clue positions
                    for (const clue of this.clues) {
                        clue.row -= minRow;
                        clue.col -= minCol;
                    }
                    
                    // Update grid
                    this.crosswordGrid = newGrid;
                    this.gridSize = Math.max(newHeight, newWidth);
                }
                
                numberGrid() {
                    let clueNumber = 1;
                    const numberedCells = {};
                    
                    // Assign numbers to cells where words start
                    for (let i = 0; i < this.clues.length; i++) {
                        const { row, col } = this.clues[i];
                        const key = `${row},${col}`;
                        
                        if (!numberedCells[key]) {
                            numberedCells[key] = clueNumber++;
                            this.clues[i].number = numberedCells[key];
                        } else {
                            this.clues[i].number = numberedCells[key];
                        }
                    }
                }
                
                renderLetterWheel() {
                    // Clear letter elements
                    if (!this.wheelContainer) return;
                    
                    const childElements = Array.from(this.wheelContainer.children);
                    for (const child of childElements) {
                        if (child.tagName.toLowerCase() !== 'svg') {
                            this.wheelContainer.removeChild(child);
                        }
                    }
                    
                    this.letterElements = [];
                    
                    // Get dimensions of wheel container
                    const wheelRect = this.wheelContainer.getBoundingClientRect();
                    const centerX = wheelRect.width / 2;
                    const centerY = wheelRect.height / 2;
                    
                    // Adjust radius and letter size based on available space
                    const isPortrait = window.matchMedia('(orientation: portrait)').matches;
                    const isMobile = window.innerWidth <= 500;
                    
                    const letterSize = isMobile || isPortrait ? 40 : 50;
                    const radius = Math.min(centerX, centerY) - (letterSize * 0.7);
                    
                    // Place all letters in a circle
                    const letterCount = this.letters.length;
                    
                    for (let i = 0; i < letterCount; i++) {
                        // Calculate position - start at the top (270 degrees) and go clockwise
                        const angle = (i * 2 * Math.PI / letterCount) - Math.PI / 2;
                        const x = centerX + radius * Math.cos(angle);
                        const y = centerY + radius * Math.sin(angle);
                        
                        const letterElement = document.createElement('div');
                        letterElement.className = 'letter';
                        letterElement.textContent = this.letters[i].toUpperCase();
                        letterElement.dataset.index = i;
                        letterElement.dataset.letter = this.letters[i];
                        
                        // Set letter size
                        letterElement.style.width = `${letterSize}px`;
                        letterElement.style.height = `${letterSize}px`;
                        letterElement.style.fontSize = `${letterSize * 0.45}px`;
                        
                        letterElement.style.left = `${x - (letterSize/2)}px`;
                        letterElement.style.top = `${y - (letterSize/2)}px`;
                        
                        // Add click handler
                        letterElement.addEventListener('click', this.handleLetterClick);
                        
                        this.letterElements.push({
                            element: letterElement,
                            index: i,
                            letter: this.letters[i],
                            x: x,
                            y: y,
                            centerX: x,
                            centerY: y
                        });
                        
                        this.wheelContainer.appendChild(letterElement);
                    }
                }
                
                renderCrosswordGrid() {
                    if (!this.crosswordGridElement) return;
                    
                    // Store current scroll position before redrawing
                    const scrollY = window.scrollY;
                    
                    this.crosswordGridElement.innerHTML = '';
                    
                    // Adjust size for the actual grid dimensions
                    const gridWidth = this.crosswordGrid[0]?.length || this.gridSize;
                    const gridHeight = this.crosswordGrid.length || this.gridSize;
                    
                    this.crosswordGridElement.style.gridTemplateColumns = `repeat(${gridWidth}, 40px)`;
                    this.crosswordGridElement.style.gridTemplateRows = `repeat(${gridHeight}, 40px)`;
                    
                    const numberedCells = {};
                    this.clues.forEach(clue => {
                        if (clue.row >= 0 && clue.row < gridHeight && 
                            clue.col >= 0 && clue.col < gridWidth) {
                            numberedCells[`${clue.row},${clue.col}`] = clue.number;
                        }
                    });
                    
                    // Keep track of cells that are part of words
                    const wordCells = new Set();
                    // Also track which words each cell belongs to for later coloring
                    const cellWords = {};
                    
                    // Track which cells have been found already
                    const foundCells = new Set();
                    
                    for (let i = 0; i < this.placedWords.length; i++) {
                        const { word, row, col, horizontal } = this.clues[i];
                        if (row < 0 || col < 0 || 
                            row >= gridHeight || col >= gridWidth) {
                            continue; // Skip words that are out of bounds
                        }
                        
                        // Check if this word has been found
                        const isFound = this.foundWords.includes(word);
                        
                        for (let j = 0; j < word.length; j++) {
                            const cellRow = horizontal ? row : row + j;
                            const cellCol = horizontal ? col + j : col;
                            const cellKey = `${cellRow},${cellCol}`;
                            
                            if (cellRow >= 0 && cellRow < gridHeight && 
                                cellCol >= 0 && cellCol < gridWidth) {
                                wordCells.add(cellKey);
                                
                                // Initialize the cell's word list if needed
                                if (!cellWords[cellKey]) {
                                    cellWords[cellKey] = [];
                                }
                                
                                // Add this word to the cell's list of words
                                cellWords[cellKey].push({
                                    word: word,
                                    index: i,
                                    letterIndex: j,
                                    isFound: isFound
                                });
                                
                                // Mark cell as found if any of its words is found
                                if (isFound) {
                                    foundCells.add(cellKey);
                                }
                            }
                        }
                    }
                    
                    // Render the grid cells
                    for (let row = 0; row < gridHeight; row++) {
                        for (let col = 0; col < gridWidth; col++) {
                            const key = `${row},${col}`;
                            const cellElement = document.createElement('div');
                            
                            if (wordCells.has(key)) {
                                // This cell is part of a word
                                const cell = this.crosswordGrid[row]?.[col];
                                
                                cellElement.className = 'crossword-cell filled';
                                cellElement.dataset.row = row;
                                cellElement.dataset.col = col;
                                
                                if (cell && cell.letter) {
                                    cellElement.dataset.letter = cell.letter;
                                    
                                    // If this cell is part of a found word or we're in debug mode
                                    if (foundCells.has(key)) {
                                        cellElement.textContent = cell.letter.toUpperCase();
                                        cellElement.classList.add('correct');
                                    } else if (this.debugMode) {
                                        cellElement.textContent = cell.letter.toUpperCase();
                                        cellElement.classList.add('debug');
                                    }
                                }
                                
                                // Add clue number if this cell starts a word
                                if (numberedCells[key]) {
                                    const numberElement = document.createElement('span');
                                    numberElement.className = 'cell-number';
                                    numberElement.textContent = numberedCells[key];
                                    cellElement.appendChild(numberElement);
                                }
                            } else {
                                // This cell is not part of any word
                                cellElement.className = 'crossword-cell empty';
                            }
                            
                            this.crosswordGridElement.appendChild(cellElement);
                        }
                    }
                    
                    // Further ensure all found words are correctly marked
                    console.log("Found words to render:", this.foundWords);
                    for (const word of this.foundWords) {
                        // Find the clue for this word (must account for case differences)
                        const clue = this.clues.find(c => c.word.toLowerCase() === word.toLowerCase());
                        if (clue) {
                            const { row, col, horizontal } = clue;
                            console.log(`Found word: "${word}" at (${row},${col}), horizontal: ${horizontal}`);
                            
                            for (let i = 0; i < word.length; i++) {
                                // If horizontal, increment column; if vertical, increment row
                                const cellRow = horizontal ? row : row + i;
                                const cellCol = horizontal ? col + i : col;
                                const cellSelector = `.crossword-cell[data-row="${cellRow}"][data-col="${cellCol}"]`;
                                const cellElement = document.querySelector(cellSelector);
                                
                                if (cellElement) {
                                    cellElement.textContent = word[i].toUpperCase();
                                    cellElement.classList.remove('debug');
                                    cellElement.classList.add('correct');
                                    console.log(`Updated cell for found word at (${cellRow},${cellCol}) with letter ${word[i].toUpperCase()}`);
                                } else {
                                    console.error(`Unable to find cell element for found word at (${cellRow},${cellCol})`);
                                }
                            }
                        } else {
                            console.error(`Unable to find clue for found word: "${word}"`);
                            // Log all clues and placed words to help debug
                            console.log("Clues available:", this.clues.map(c => c.word));
                            console.log("Placed words:", this.placedWords);
                        }
                    }
                    
                    // After rendering call adjustLayout to properly size cells
                    this.adjustLayout();
                    
                    // Restore scroll position
                    window.scrollTo(0, scrollY);
                    
                    // Additional layout adjustment after a short delay to ensure grid is properly scaled
                    setTimeout(() => {
                        this.adjustLayout();
                        window.scrollTo(0, scrollY);
                    }, 50);
                }
                
                toggleDebugView() {
                    this.debugMode = !this.debugMode;
                    
                    // Toggle debug button text
                    if (this.debugBtn) {
                        this.debugBtn.textContent = this.debugMode ? "Hide Answers" : "Show Answers";
                    }
                    
                    // Re-render the grid with debug info
                    this.renderCrosswordGrid();
                    
                    // If in debug mode, check the grid structure
                    if (this.debugMode) {
                        this.checkGridStructure();
                    }
                }
                
                checkGridStructure() {
                    console.log("--- Debug: Crossword Structure ---");
                    console.log("Placed Words:", this.placedWords);
                    console.log("Word Placements:", this.clues);
                    
                    // Create a visual representation of the grid
                    let gridVisual = '';
                    for (let r = 0; r < this.crosswordGrid.length; r++) {
                        let row = '';
                        for (let c = 0; c < (this.crosswordGrid[r]?.length || 0); c++) {
                            if (!this.crosswordGrid[r][c]) {
                                row += '.';
                            } else {
                                const cell = this.crosswordGrid[r][c];
                                row += cell.letter ? cell.letter : '.';
                            }
                        }
                        gridVisual += row + '\n';
                    }
                    
                    console.log("Grid Layout:");
                    console.log(gridVisual);
                    
                    // Check for adjacency issues
                    this.checkAdjacencyIssues();
                }
                
                checkAdjacencyIssues() {
                    const issues = [];
                    
                    for (let r = 0; r < this.crosswordGrid.length; r++) {
                        for (let c = 0; c < (this.crosswordGrid[r]?.length || 0); c++) {
                            if (!this.crosswordGrid[r][c] || !this.crosswordGrid[r][c].letter) continue;
                            
                            const cell = this.crosswordGrid[r][c];
                            const wordIndices = cell.wordIndices || [];
                            
                            if (wordIndices.length === 1) {
                                const directions = [[0, 1], [1, 0], [0, -1], [-1, 0]];
                                
                                for (const [dr, dc] of directions) {
                                    const nr = r + dr;
                                    const nc = c + dc;
                                    
                                    if (nr < 0 || nr >= this.crosswordGrid.length || 
                                        nc < 0 || !this.crosswordGrid[nr] || 
                                        nc >= this.crosswordGrid[nr].length) {
                                        continue; // Skip out of bounds
                                    }
                                    
                                    const neighborCell = this.crosswordGrid[nr][nc];
                                    
                                    if (!neighborCell || !neighborCell.letter) continue;
                                    
                                    const neighborWordIndices = neighborCell.wordIndices || [];
                                    
                                    if (neighborWordIndices.length > 0 && 
                                        !neighborWordIndices.includes(wordIndices[0])) {
                                        issues.push({
                                            row: r,
                                            col: c,
                                            letter: cell.letter,
                                            neighborRow: nr,
                                            neighborCol: nc,
                                            neighborLetter: neighborCell.letter
                                        });
                                    }
                                }
                            }
                        }
                    }
                    
                    if (issues.length > 0) {
                        console.error(`Found ${issues.length} adjacency issues:`, issues);
                        
                        // Highlight issues in the grid
                        for (const issue of issues) {
                            const cellSelector = `.crossword-cell[data-row="${issue.row}"][data-col="${issue.col}"]`;
                            const cell = document.querySelector(cellSelector);
                            if (cell) {
                                cell.style.backgroundColor = 'rgba(255, 0, 0, 0.3)';
                            }
                        }
                    } else {
                        console.log("No adjacency issues found! 👍");
                    }
                }
                
                handleLetterClick(e) {
                    // Stop event propagation to prevent it from triggering the drag events
                    e.stopPropagation();
                    
                    const index = parseInt(e.target.dataset.index);
                    const letter = e.target.dataset.letter;
                    
                    // Don't select the same letter twice
                    if (this.selectedIndices.includes(index)) {
                        return;
                    }
                    
                    // Add it to the current selection (accumulating letters)
                    this.selectedIndices.push(index);
                    e.target.classList.add('selected');
                    
                    // Add to path
                    const letterInfo = this.letterElements.find(item => item.index === index);
                    if (letterInfo) {
                        this.pathPoints.push({
                            x: letterInfo.centerX,
                            y: letterInfo.centerY
                        });
                        
                        this.updateSelectionPath();
                        this.updateCurrentWord();
                    }
                    
                    // Provide visual/haptic feedback for the tap
                    e.target.style.transform = 'scale(1.1)';
                    setTimeout(() => {
                        if (e.target) e.target.style.transform = '';
                    }, 100);
                }
                
                handleTouchStart(e) {
                    e.preventDefault(); // Prevent scrolling
                    if (e.touches.length === 1) {
                        const touch = e.touches[0];
                        
                        // Store start position and time for differentiating taps vs drags
                        this.touchStartX = touch.clientX;
                        this.touchStartY = touch.clientY;
                        this.touchStartTime = Date.now();
                        this.hasMoved = false;
                        
                        this.startDrag(touch.clientX, touch.clientY);
                        
                        document.addEventListener('touchmove', this.handleTouchMove, { passive: false });
                        document.addEventListener('touchend', this.handleTouchEnd);
                    }
                }
                
                handleMouseDown(e) {
                    // Store start position and time for differentiating clicks vs drags
                    this.mouseStartX = e.clientX;
                    this.mouseStartY = e.clientY;
                    this.mouseStartTime = Date.now();
                    this.hasMoved = false;
                    
                    this.startDrag(e.clientX, e.clientY);
                    
                    document.addEventListener('mousemove', this.handleMouseMove);
                    document.addEventListener('mouseup', this.handleMouseUp);
                }
                
                startDrag(clientX, clientY) {
                    this.isDragging = true;
                    
                    // Get wheel container position
                    if (!this.wheelContainer) return;
                    
                    const rect = this.wheelContainer.getBoundingClientRect();
                    const x = clientX - rect.left;
                    const y = clientY - rect.top;
                    
                    // Check if the touch/click is on a letter
                    this.checkLetterSelection(x, y);
                }
                
                handleTouchMove(e) {
                    e.preventDefault();
                    if (this.isDragging && e.touches.length === 1) {
                        const touch = e.touches[0];
                        if (!this.wheelContainer) return;
                        
                        // Mark that we've moved (to differentiate from taps)
                        const moveDistance = Math.sqrt(
                            Math.pow(touch.clientX - this.touchStartX, 2) + 
                            Math.pow(touch.clientY - this.touchStartY, 2)
                        );
                        
                        if (moveDistance > 10) {
                            this.hasMoved = true;
                        }
                        
                        const rect = this.wheelContainer.getBoundingClientRect();
                        const x = touch.clientX - rect.left;
                        const y = touch.clientY - rect.top;
                        
                        this.checkLetterSelection(x, y);
                    }
                }
                
                handleMouseMove(e) {
                    if (this.isDragging) {
                        if (!this.wheelContainer) return;
                        
                        // Mark that we've moved (to differentiate from clicks)
                        const moveDistance = Math.sqrt(
                            Math.pow(e.clientX - this.mouseStartX, 2) + 
                            Math.pow(e.clientY - this.mouseStartY, 2)
                        );
                        
                        if (moveDistance > 10) {
                            this.hasMoved = true;
                        }
                        
                        const rect = this.wheelContainer.getBoundingClientRect();
                        const x = e.clientX - rect.left;
                        const y = e.clientY - rect.top;
                        
                        this.checkLetterSelection(x, y);
                    }
                }
                
                checkLetterSelection(x, y) {
                    // Check if the position is on a letter
                    for (let i = 0; i < this.letterElements.length; i++) {
                        const letterInfo = this.letterElements[i];
                        if (!letterInfo) continue;
                        
                        // Calculate distance to letter center
                        const dx = x - letterInfo.centerX;
                        const dy = y - letterInfo.centerY;
                        const distance = Math.sqrt(dx * dx + dy * dy);
                        
                        // If within the letter circle and not already selected
                        if (distance < 25 && !this.selectedIndices.includes(letterInfo.index)) {
                            // Add to selection
                            this.selectedIndices.push(letterInfo.index);
                            if (letterInfo.element) {
                                letterInfo.element.classList.add('selected');
                            }
                            
                            // Add point to path
                            this.pathPoints.push({
                                x: letterInfo.centerX,
                                y: letterInfo.centerY
                            });
                            
                            // Update the drawn path
                            this.updateSelectionPath();
                            
                            // Update current word
                            this.updateCurrentWord();
                        }
                    }
                }
                
                handleTouchEnd(e) {
                    document.removeEventListener('touchmove', this.handleTouchMove);
                    document.removeEventListener('touchend', this.handleTouchEnd);
                    
                    if (this.isDragging) {
                        // Check if this was a tap or a drag
                        const endTime = Date.now();
                        const tapDuration = endTime - this.touchStartTime;
                        
                        if (!this.hasMoved && tapDuration < 200) {
                            // This was a tap, not a drag - don't end the selection
                            this.isDragging = false;
                        } else {
                            // This was a drag - end the selection
                            this.endDrag();
                        }
                    }
                }
                
                handleMouseUp(e) {
                    document.removeEventListener('mousemove', this.handleMouseMove);
                    document.removeEventListener('mouseup', this.handleMouseUp);
                    
                    if (this.isDragging) {
                        // Check if this was a click or a drag
                        const endTime = Date.now();
                        const clickDuration = endTime - this.mouseStartTime;
                        
                        if (!this.hasMoved && clickDuration < 200) {
                            // This was a click, not a drag - don't end the selection
                            this.isDragging = false;
                        } else {
                            // This was a drag - end the selection
                            this.endDrag();
                        }
                    }
                }
                
                endDrag() {
                    this.isDragging = false;
                    
                    // If we have a valid word, submit it
                    if (this.currentWord.length >= 3) {
                        this.submitWord();
                    } else {
                        // Only clear if this was a true drag operation and not discrete clicks
                        // Check if we have any points in our path
                        if (this.pathPoints.length > 1 && this.hasMoved) {
                            this.clearSelection();
                        }
                    }
                }
                
                updateSelectionPath() {
                    if (!this.selectionPath) return;
                    
                    if (this.pathPoints.length === 0) {
                        this.selectionPath.setAttribute('d', '');
                        return;
                    }
                    
                    let d = `M ${this.pathPoints[0].x} ${this.pathPoints[0].y}`;
                    for (let i = 1; i < this.pathPoints.length; i++) {
                        d += ` L ${this.pathPoints[i].x} ${this.pathPoints[i].y}`;
                    }
                    
                    this.selectionPath.setAttribute('d', d);
                }
                
                updateCurrentWord() {
                    this.currentWord = '';
                    
                    // Add the selected letters to form the word
                    for (const index of this.selectedIndices) {
                        const letterInfo = this.letterElements.find(item => item.index === index);
                        if (letterInfo) {
                            this.currentWord += letterInfo.letter;
                        }
                    }
                    
                    if (this.currentWordElement) {
                        this.currentWordElement.textContent = this.currentWord.toUpperCase();
                    }
                }
                
                clearSelection() {
                    // Clear the selection
                    this.selectedIndices = [];
                    this.currentWord = '';
                    if (this.currentWordElement) {
                        this.currentWordElement.textContent = '';
                    }
                    this.pathPoints = [];
                    this.updateSelectionPath();
                    
                    // Reset letter styles
                    this.letterElements.forEach(info => {
                        if (info.element) {
                            info.element.classList.remove('selected');
                        }
                    });
                }
                
                shuffleLetters() {
                    // Shuffle the letters
                    for (let i = this.letters.length - 1; i > 0; i--) {
                        const j = Math.floor(Math.random() * (i + 1));
                        [this.letters[i], this.letters[j]] = [this.letters[j], this.letters[i]];
                    }
                    
                    this.clearSelection();
                    this.renderLetterWheel();
                }
                
                submitWord() {
                    // Check if the word is valid and not already found
                    if (this.currentWord.length < 3) {
                        this.displayMessage('Word is too short!', 'error');
                        return;
                    }
                    
                    // Check if word was already found
                    if (this.foundWords.includes(this.currentWord)) {
                        this.displayMessage('Word already found!', 'error');
                        this.clearSelection();
                        return;
                    }
                    
                    // Check if word was already attempted
                    if (this.invalidAttempts.has(this.currentWord)) {
                        this.displayMessage('Already tried this word!', 'error');
                        this.clearSelection();
                        return;
                    }
                    
                    // Since we've enhanced grid generation to include all words,
                    // A word that can be spelled from our letters should always be in the grid
                    
                    // Check if word is in our valid words list (words that are in the grid)
                    if (!this.validWords.includes(this.currentWord)) {
                        this.invalidAttempts.add(this.currentWord);
                        this.displayMessage('Not a valid word!', 'error');
                        this.updateWordsList();
                        this.clearSelection();
                        return;
                    }
                    
                    // Word is valid and new, add it to found words
                    this.foundWords.push(this.currentWord);
                    
                    // Check if this is the longest word
                    if (this.currentWord === this.longestWord && !this.longestWordFound) {
                        this.celebrateLongestWord();
                        this.longestWordFound = true;
                    } else {
                        this.displayMessage('Word found!', 'success');
                    }
                    
                    // Get the current word before clearing the selection
                    const wordToUpdate = this.currentWord;
                    
                    // Update the crossword grid with the new word
                    this.renderCrosswordGrid(); // Force a full redraw first
                    
                    // Then update the specific word cells
                    setTimeout(() => {
                        this.updateCrosswordForWord(wordToUpdate);
                    }, 10);
                    
                    // Update the words list
                    this.updateWordsList();
                    
                    // Add celebration animation to the found word in the list
                    this.animateFoundWord(wordToUpdate);
                    
                    // Clear the selection
                    this.clearSelection();
                    
                    // Check for game completion
                    this.checkCompletion();
                }
                
                updateCrosswordForWord(word) {
                    // Find all cells in the crossword that correspond to the word
                    let wordUpdated = false;
                    const foundWord = word.toLowerCase();
                    
                    // First log the word we're trying to update for debugging
                    console.log(`Updating grid for word: "${foundWord}"`);
                    
                    // Find the word in the placed words
                    for (let i = 0; i < this.placedWords.length; i++) {
                        const placedWord = this.placedWords[i];
                        
                        if (placedWord === foundWord) {
                            const { row, col, horizontal } = this.clues[i];
                            wordUpdated = true;
                            
                            console.log(`Found word in grid: "${placedWord}" at (${row},${col}), horizontal: ${horizontal}`);
                            
                            // Mark the cells for this word as correct
                            for (let j = 0; j < placedWord.length; j++) {
                                const cellRow = horizontal ? row : row + j;
                                const cellCol = horizontal ? col + j : col;
                                
                                // Find the corresponding DOM element
                                const cellSelector = `.crossword-cell[data-row="${cellRow}"][data-col="${cellCol}"]`;
                                const cellElement = document.querySelector(cellSelector);
                                
                                if (cellElement) {
                                    cellElement.textContent = placedWord[j].toUpperCase();
                                    cellElement.classList.add('correct');
                                    cellElement.classList.remove('debug');
                                    console.log(`Updated cell at (${cellRow},${cellCol}) with letter ${placedWord[j].toUpperCase()}`);
                                } else {
                                    console.error(`Cell element not found at (${cellRow},${cellCol}) for letter ${placedWord[j]}`);
                                }
                            }
                        }
                    }
                    
                    // If the word wasn't found in the grid, display a message
                    if (!wordUpdated) {
                        console.error(`Word "${foundWord}" not found in grid placement`);
                        
                        // Dump the contents of placedWords for debugging
                        console.log("All placed words:", this.placedWords);
                        console.log("All clues:", this.clues);
                    }
                    
                    // Force a layout adjustment to ensure the grid is properly updated
                    this.adjustLayout();
                }
                
                updateCrosswordGrid() {
                    // Find all cells in the crossword that correspond to the current word
                    let wordUpdated = false;
                    
                    // Store scroll position
                    const scrollY = window.scrollY;
                    
                    for (let i = 0; i < this.placedWords.length; i++) {
                        const word = this.placedWords[i];
                        
                        if (word === this.currentWord) {
                            const { row, col, horizontal } = this.clues[i];
                            wordUpdated = true;
                            
                            // Mark the cells for this word as correct
                            for (let j = 0; j < word.length; j++) {
                                const cellRow = horizontal ? row : row + j;
                                const cellCol = horizontal ? col + j : col;
                                
                                // Find the corresponding DOM element
                                const cellSelector = `.crossword-cell[data-row="${cellRow}"][data-col="${cellCol}"]`;
                                const cellElement = document.querySelector(cellSelector);
                                
                                if (cellElement) {
                                    cellElement.textContent = word[j].toUpperCase();
                                    cellElement.classList.add('correct');
                                    cellElement.classList.remove('debug');
                                }
                            }
                        }
                    }
                    
                    // If the word wasn't found in the grid, display a message
                    if (!wordUpdated) {
                        console.log(`Word "${this.currentWord}" not found in grid placement`);
                    }
                    
                    // Re-adjust layout after updating grid to ensure proper sizing
                    this.adjustLayout();
                    
                    // Restore scroll position
                    window.scrollTo(0, scrollY);
                }
                
                updateWordsList() {
                    if (!this.wordsFoundList || !this.wordsFoundCount || !this.totalWordsCount || !this.invalidWordsList) return;
                    
                    // Update the found words list
                    this.wordsFoundList.innerHTML = '';
                    this.wordsFoundCount.textContent = this.foundWords.length;
                    this.totalWordsCount.textContent = this.placedWords.length;
                    
                    // Sort found words alphabetically
                    const sortedWords = [...this.foundWords].sort();
                    
                    for (const word of sortedWords) {
                        const listItem = document.createElement('li');
                        listItem.textContent = word.toUpperCase();
                        
                        // Highlight the longest word if it's found
                        if (word === this.longestWord) {
                            listItem.style.backgroundColor = '#ffd700';
                            listItem.style.color = '#333';
                        }
                        
                        this.wordsFoundList.appendChild(listItem);
                    }
                    
                    // Add longest word info section if we have a longest word
                    if (this.longestWord && this.wordsFoundList.parentNode) {
                        let longestWordInfo = document.getElementById('longest-word-info');
                        
                        if (!longestWordInfo) {
                            longestWordInfo = document.createElement('div');
                            longestWordInfo.id = 'longest-word-info';
                            longestWordInfo.className = 'longest-word-info';
                            this.wordsFoundList.parentNode.insertBefore(longestWordInfo, this.wordsFoundList.nextSibling);
                        }
                        
                        const foundStatus = this.longestWordFound ? '✓ Found!' : 'Not found yet';
                        longestWordInfo.innerHTML = `Longest Word: ${this.longestWordFound ? this.longestWord.toUpperCase() : '???'} <span style="float:right">${foundStatus}</span>`;
                    }
                    
                    // Update invalid attempts list
                    this.invalidWordsList.innerHTML = '';
                    const sortedInvalid = [...this.invalidAttempts].sort();
                    for (const word of sortedInvalid) {
                        const listItem = document.createElement('li');
                        listItem.textContent = word.toUpperCase();
                        listItem.classList.add('invalid');
                        this.invalidWordsList.appendChild(listItem);
                    }
                }
                
                displayMessage(text, type) {
                    if (!this.messageElement) return;
                    
                    this.messageElement.textContent = text;
                    this.messageElement.className = `message ${type}`;
                    
                    // Clear the message after a short time
                    setTimeout(() => {
                        // Fade out effect
                        this.messageElement.style.opacity = '0';
                        this.messageElement.style.transition = 'opacity 0.5s';
                        
                        // Clear after fade
                        setTimeout(() => {
                            this.messageElement.textContent = '';
                            this.messageElement.className = 'message';
                            this.messageElement.style.opacity = '1';
                            this.messageElement.style.transition = '';
                        }, 500);
                    }, 1500);
                }
                
                checkCompletion() {
                    // Check if all words have been found
                    let allWordsFound = true;
                    
                    for (const word of this.placedWords) {
                        if (!this.foundWords.includes(word)) {
                            allWordsFound = false;
                            break;
                        }
                    }
                    
                    if (allWordsFound) {
                        this.displayMessage('Puzzle complete! Congratulations!', 'success');
                        
                        // Disable controls
                        if (this.submitBtn) this.submitBtn.disabled = true;
                        if (this.clearBtn) this.clearBtn.disabled = true;
                        if (this.shuffleBtn) this.shuffleBtn.disabled = true;
                    }
                }
                
                findLongestWord() {
                    this.longestWord = '';
                    for (const word of this.placedWords) {
                        if (word.length > this.longestWord.length) {
                            this.longestWord = word;
                        }
                    }
                    console.log(`Longest word in the puzzle: ${this.longestWord}`);
                    this.longestWordFound = false;
                }
                
                celebrateLongestWord() {
                    if (!this.longestWordBanner || !this.longestWordText) return;
                    
                    // Set the longest word text
                    this.longestWordText.textContent = this.longestWord.toUpperCase();
                    
                    // Show the banner
                    this.longestWordBanner.classList.add('show');
                    
                    // Display special message
                    this.displayMessage(`Amazing! You found the longest word: ${this.longestWord.toUpperCase()}!`, 'success');
                    
                    // Hide banner after a few seconds
                    setTimeout(() => {
                        this.longestWordBanner.classList.remove('show');
                    }, 3000);
                }
                
                animateFoundWord(word) {
                    setTimeout(() => {
                        // Find the list item for this word
                        const listItems = this.wordsFoundList.querySelectorAll('li');
                        for (const item of listItems) {
                            if (item.textContent.toLowerCase() === word.toUpperCase()) {
                                item.classList.add('celebrating');
                                
                                // Remove the class after animation completes
                                setTimeout(() => {
                                    item.classList.remove('celebrating');
                                }, 500);
                                
                                break;
                            }
                        }
                    }, 100); // Small delay to ensure the list is updated
                }
            }
            
            // Initialize the game once DOM is fully loaded
            new WordWheelCrossword();
        });
    </script>
</body>
</html>
